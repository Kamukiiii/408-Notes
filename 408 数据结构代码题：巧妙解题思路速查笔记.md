

------

# 408 数据结构代码题：巧妙解题思路速查笔记

这是在考研数据结构代码大题中，将复杂度降维、实现原地操作等高效解法的核心思想。

## Ⅰ. 链表操作与双指针同步（O(N) 时间 & O(1) 辅助空间）

| 核心思想              | 解决的问题                                                  | 关键技巧                                                     | “妙”在哪里 (高效性/空间)                               |
| --------------------- | ----------------------------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------ |
| **长度对齐/路径平衡** | 查找两个链表的相交点、**有序链表的合并去重**。              | **双指针先走 k 步**，消除长度差 k；或通过归并合并时引入 `last_val` 去重。 | 避免 O(N2) 的暴力比较，只需一次 O(N) 遍历即可定位。    |
| **快慢指针**          | 判断链表是否有环、查找环的起始点、查找**倒数第 k 个节点**。 | 两指针以不同速度（1 步 vs 2 步），或固定距离 k 同步前进。    | 利用相对速度差，巧妙地将距离信息转化为相遇点或终止点。 |
| **原地逆置/头插法**   | 链表的原地逆置、**合并操作中修改指向**。                    | 仅用 O(1) 辅助空间（几个指针），通过改变 `next` 指向实现链表的颠倒或重连。 | O(1) 辅助空间，极大节省内存。                          |

------

## Ⅱ. 数组/串操作与双端对撞（O(N) 时间 & O(1) 辅助空间）

| 核心思想         | 解决的问题                                                   | 关键技巧                                                     | “妙”在哪里 (高效性/空间)                                     |
| ---------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **双端对撞指针** | 数组元素的**原地划分**（如奇偶分离）、**类快速排序的 Partition**。 | **L 和 R 指针**从两端向中间移动，遇不合条件元素进行**原地交换**。 | 在一次 O(N) 遍历中完成元素的归位，不需要额外数组。           |
| **三次逆转**     | 数组或字符串的**循环左移/右移**。                            | 将序列 AB 变为 BA：逆转 A (→ArB)，逆转 B (→ArBr)，整体逆转 (→BA。 | 经典 O(N) 时间复杂度、**O(1) 辅助空间**的原地操作。          |
| **滑动窗口**     | 查找固定长度子序列的最大和、最长子串等。                     | **双指针**（窗口边界）同步向右移动，保持或动态调整窗口大小。 | 利用上一步的结果，避免重复计算，将子序列求和或检查复杂度从 O(N2) 降到 O(N)。 |

------

## Ⅲ. 树的性质与高效遍历（O(N) 时间）

| 核心思想             | 解决的问题                      | 关键技巧                                                     | “妙”在哪里 (高效性/空间)                                     |
| -------------------- | ------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **中序遍历单调性**   | **判断二叉搜索树 (BST)**。      | 在中序遍历时，用一个**全局/引用变量**记录**前一个**节点值，只需判断当前值是否 > 前一个值。 | 避免将所有节点存入数组进行排序，判断过程在 O(N) 遍历中同步完成。 |
| **Morris 遍历**      | **O(1) 辅助空间的二叉树遍历**。 | 利用空闲的右子指针，暂时连接到中序后继，完成遍历后恢复。     | **消除递归栈和常规辅助栈**，将空间复杂度降至 O(1)。          |
| **后序遍历递归定义** | 计算树的高度/深度。             | 树的高度天然是左右子树高度的最大值加一。                     | 利用后序遍历的特性，在回溯时高效传递和计算深度信息。         |

------

## Ⅳ. 图与集合的高效判定

| 核心思想               | 解决的问题                                      | 关键技巧                                                     | “妙”在哪里 (高效性/空间)   |
| ---------------------- | ----------------------------------------------- | ------------------------------------------------------------ | -------------------------- |
| **入度优先/拓扑排序**  | 有向无环图 (DAG) 的顶点排序、判断图中是否有环。 | **Kahn 算法**：利用所有顶点的**入度**。优先处理入度为 0 的节点。 | 解决图的排序问题，实现 $O( |
| **遍历后检查 visited** | **判断根结点**（顶点 r 能否到达所有节点）。     | 从 r 开始 DFS/BFS 遍历一次后，检查 **visited 数组**中 True 的数量是否等于总顶点数 $ | V                          |